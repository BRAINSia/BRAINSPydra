import pydra
from pathlib import Path
import nest_asyncio
import time
from shutil import copyfile
import json
import os
import glob
from configparser import ConfigParser

import attr
from nipype.interfaces.base import (
    Directory,
    File,
)
from pydra import ShellCommandTask
from pydra.engine.specs import SpecInfo, ShellSpec

from registration import BRAINSResample
from segmentation.specialized import BRAINSConstellationDetector

@pydra.mark.task
def get_subject(subject_list):
    return subject_list

@pydra.mark.task
def append_filename(filename="", append_str="", extension="", directory=""):
    new_filename = f"{Path(Path(directory) / Path(Path(filename).with_suffix('').with_suffix('').name))}{append_str}{extension}"
    return new_filename 

@pydra.mark.task
def copy_from_cache(cache_path, output_dir):
    copyfile(cache_path, Path(output_dir) / Path(cache_path).name)

if __name__ == "__main__":
    nest_asyncio.apply()
    config = ConfigParser()
    config.read("config.ini")

    # Set the location of the cache and clear its contents before running 
    output_dir = config["OUTPUT"]["output_dir"]
    cache_dir = config["OUTPUT"]["cache_dir"]
    os.system(f'rm -rf {cache_dir}/*') # Only deleting cache now as the pipeline is being developed and tested
 
    # Get the subject data listed in the subject_jsons.json file 
    subject_t1s = []
    with open(config["SOURCE"]["subject_jsons_file"]) as json_file:
        data = json.load(json_file)
        for subject in data:
            subject_t1s.append(data[subject]["t1"])
    
    source_node = pydra.Workflow(name="source_node", input_spec=["t1"],)
    source_node.split("t1")
    source_node.inputs.t1 = subject_t1s
    
    # Before workflow, source node - takes in all subjects as list and outputs an iterable (1 subject information) - attached to the input spec of workflow
    # output_spec should be connected to a sink node
    # source node: absolute terms -  an outer workflow interfaces with sink and source nodes, source and sink should be generic and reusable
    # everything between source and sink are generic and do not interact with real world - that is the job of source and sink
    # workflow virtual files
    # sink takes from virtual to absolute
    # Decouple reference files, but they have different locations but I ask for the directory

    # Define the workflow
    wf = pydra.Workflow(name="wf",input_spec=["t1"], t1=source_node.lzin.t1, cache_dir=cache_dir)
    #                              output_spec # outputs from the set_output, autogenerated paths of cache)
    # Set the filenames of the outputs of BCD
    wf.add(append_filename(name="outputLandmarksInInputSpace",       filename=wf.lzin.t1, append_str="_BCD_Original",                extension=".fcsv"))
    wf.add(append_filename(name="outputResampledVolume",             filename=wf.lzin.t1, append_str="_BCD_ACPC",                    extension=".nii.gz"))
    wf.add(append_filename(name="outputTransform",                   filename=wf.lzin.t1, append_str="_BCD_Original2ACPC_transform", extension=".h5"))
    wf.add(append_filename(name="outputLandmarksInACPCAlignedSpace", filename=wf.lzin.t1, append_str="_BCD_ACPC_Landmarks",          extension=".fcsv"))
    wf.add(append_filename(name="writeBranded2DImage",               filename=wf.lzin.t1, append_str="_BCD_Branded2DQCimage",        extension=".png"))

    # Set the inputs of BCD
    bcd = BRAINSConstellationDetector("BRAINSConstellationDetector").get_task()
    bcd.inputs.inputVolume =                       wf.lzin.t1
    bcd.inputs.inputTemplateModel =                config["BCD"]["inputTemplateModel"]
    bcd.inputs.LLSModel =                          config["BCD"]["LLSModel"]
    bcd.inputs.atlasLandmarkWeights =              config["BCD"]["atlasLandmarkWeights"]
    bcd.inputs.atlasLandmarks =                    config["BCD"]["atlasLandmarks"]
    bcd.inputs.houghEyeDetectorMode =              config["BCD"]["houghEyeDetectorMode"]
    bcd.inputs.acLowerBound =                      config["BCD"]["acLowerBound"]
    bcd.inputs.interpolationMode =                 config["BCD"]["interpolationMode"]
    bcd.inputs.outputLandmarksInInputSpace =       wf.outputLandmarksInInputSpace.lzout.out 
    bcd.inputs.outputResampledVolume =             wf.outputResampledVolume.lzout.out 
    bcd.inputs.outputTransform =                   wf.outputTransform.lzout.out 
    bcd.inputs.outputLandmarksInACPCAlignedSpace = wf.outputLandmarksInACPCAlignedSpace.lzout.out 
    bcd.inputs.writeBranded2DImage =               wf.writeBranded2DImage.lzout.out 
    wf.add(bcd)

    # Set the filename of the output of Resample
    wf.add(append_filename(name="resampledOutputVolume", filename=wf.lzin.t1, append_str="_resampled", extension=".nii.gz"))
 
    # Set the inputs of Resample
    resample = BRAINSResample("BRAINSResample").get_task()
    resample.inputs.inputVolume =       wf.BRAINSConstellationDetector.lzout.outputResampledVolume
    resample.inputs.interpolationMode = config["RESAMPLE"]["interpolationMode"]
    resample.inputs.pixelType =         config["RESAMPLE"]["pixelType"]        
    resample.inputs.referenceVolume =   wf.BRAINSConstellationDetector.lzout.outputResampledVolume 
    resample.inputs.warpTransform =     wf.BRAINSConstellationDetector.lzout.outputTransform 
    resample.inputs.outputVolume =      wf.resampledOutputVolume.lzout.out 
    wf.add(resample)

    # Set the outputs of the entire workflow
    wf.set_output(
        [
            ("outputLandmarksInInputSpace",       wf.BRAINSConstellationDetector.lzout.outputLandmarksInInputSpace),
            ("outputResampledVolume",             wf.BRAINSConstellationDetector.lzout.outputResampledVolume),
            ("outputTransform",                   wf.BRAINSConstellationDetector.lzout.outputTransform),
            ("outputLandmarksInACPCAlignedSpace", wf.BRAINSConstellationDetector.lzout.outputLandmarksInACPCAlignedSpace),
            ("writeBranded2DImage",               wf.BRAINSConstellationDetector.lzout.writeBranded2DImage),
            ("outputVolume",             wf.BRAINSResample.lzout.outputVolume),
        ]
    )



    source_node.add(wf)
    source_node.set_output(
        [
            ("outputLandmarksInInputSpace",       source_node.wf.lzout.outputLandmarksInInputSpace),
            ("outputResampledVolume",             source_node.wf.lzout.outputResampledVolume),
            ("outputTransform",                   source_node.wf.lzout.outputTransform),
            ("outputLandmarksInACPCAlignedSpace", source_node.wf.lzout.outputLandmarksInACPCAlignedSpace),
            ("writeBranded2DImage",               source_node.wf.lzout.writeBranded2DImage),
            ("outputVolume",                      source_node.wf.lzout.outputVolume),
        ]
    )


    sink_node = pydra.Workflow(name="sink_node", input_spec=["outputLandmarksInInputSpace", "outputResampledVolume", "outputTransform", "outputLandmarksInACPCAlignedSpace", "writeBranded2DImage", "outputVolume"])
       

    # Copy the files from the cache to the output directory so the resulting files can be accessed
    sink_node.add(copy_from_cache(name="outputLandmarksInInputSpaceWritten",       cache_path=source_node.lzout.outputLandmarksInInputSpace,       output_dir=output_dir))
    sink_node.add(copy_from_cache(name="outputResampledVolumeWritten",             cache_path=source_node.lzout.outputResampledVolume,             output_dir=output_dir))
    sink_node.add(copy_from_cache(name="outputTransformWritten",                   cache_path=source_node.lzout.outputTransform,                   output_dir=output_dir))
    sink_node.add(copy_from_cache(name="outputLandmarksInACPCAlignedSpaceWritten", cache_path=source_node.lzout.outputLandmarksInACPCAlignedSpace, output_dir=output_dir))
    sink_node.add(copy_from_cache(name="writeBranded2DImageWritten",               cache_path=source_node.lzout.writeBranded2DImage,               output_dir=output_dir))
    sink_node.add(copy_from_cache(name="outputVolumeWritten",                      cache_path=source_node.lzout.outputVolume,                                   output_dir=output_dir))
 
    sink_node.set_output(
        [
            ("outputLandmarksInInputSpace",       sink_node.outputLandmarksInInputSpaceWritten.lzout.out),
            ("outputResampledVolume",             sink_node.outputResampledVolumeWritten.lzout.out),
            ("outputTransform",                   sink_node.outputTransformWritten.lzout.out),
            ("outputLandmarksInACPCAlignedSpace", sink_node.outputLandmarksInACPCAlignedSpaceWritten.lzout.out),
            ("writeBranded2DImage",               sink_node.writeBranded2DImageWritten.lzout.out),
            ("outputVolume",                      sink_node.outputVolumeWritten.lzout.out)
        ]
    )   
#    source_node.add(sink_node)
    sink_node.add(source_node)

    t0 = time.time() 
    # Run the pipeline
    with pydra.Submitter(plugin="cf") as sub:
        sub(sink_node)
    result = sink_node.result()
    print(result)
    print(f"total time: {time.time() - t0}")
