import pydra
import os
from pathlib import Path
from BIDSFilename import *
import nest_asyncio
import time
import uuid

import attr
from nipype.interfaces.base import (
    Directory,
    File,
    InputMultiPath,
    OutputMultiPath,
    traits,
)
from pydra import ShellCommandTask
from pydra.engine.specs import SpecInfo, ShellSpec

# Get the BCD SEM autogenerated class
from segmentation.specialized import BRAINSConstellationDetector


nest_asyncio.apply()


def fill_BRAINSConstellationDetector(inputVolPath="/localscratch/Users/cjohnson30/BCD_Practice/t1w_examples2/", 
                                     inputVolGlob="*",
                                     outputDir="/localscratch/Users/cjohnson30/output_dir",
                                     inputTemplateModel="/Shared/sinapse/CACHE/20200915_PREDICTHD_base_CACHE/Atlas/20141004_BCD/T1_50Lmks.mdl",
                                     LLSModel = "/Shared/sinapse/CACHE/20200915_PREDICTHD_base_CACHE/Atlas/20141004_BCD/LLSModel_50Lmks.h5",
                                     acLowerBound = 80.000000,
                                     atlasLandmarkWeights = "/Shared/sinapse/CACHE/20200915_PREDICTHD_base_CACHE/Atlas/20141004_BCD/template_weights_50Lmks.wts",
                                     atlasLandmarks = "/Shared/sinapse/CACHE/20200915_PREDICTHD_base_CACHE/Atlas/20141004_BCD/template_landmarks_50Lmks.fcsv",
                                     houghEyeDetectorMode = 1,
                                     interpolationMode = "Linear",
                                     ):
    # Get the SEM generated pydra task for BRAINSToolsBrainsConstellationDetector
    bcd = BRAINSConstellationDetector()
    task = bcd.task
    
    # Make a list of all the paths to be used as input paths
    p = Path(inputVolPath)
    all_t1 = p.glob(inputVolGlob)
    filename_objs = list(all_t1)
    input_vols = []
    for t1 in filename_objs:
        input_vols.append(str(t1))
    
    # Define the inputs to the pydra task
    task.inputs.inputTemplateModel = inputTemplateModel 
    task.inputs.LLSModel = LLSModel
    task.inputs.acLowerBound = acLowerBound
    task.inputs.atlasLandmarkWeights = atlasLandmarkWeights
    task.inputs.atlasLandmarks = atlasLandmarks
    task.inputs.houghEyeDetectorMode = houghEyeDetectorMode
    task.inputs.interpolationMode = interpolationMode
    task.inputs.inputVolume = input_vols
    task.inputs.resultsDir = outputDir
    task.inputs.outputLandmarksInInputSpace = [
        f"{task.inputs.resultsDir}/{Path(x).with_suffix('').with_suffix('').name}_BCD_Original.fcsv"
        for x in input_vols
    ]
    task.inputs.outputResampledVolume = [
        f"{task.inputs.resultsDir}/{Path(x).with_suffix('').with_suffix('').name}_BCD_ACPC.nii.gz"
        for x in input_vols
    ]
    task.inputs.outputTransform = [
        f"{task.inputs.resultsDir}/{Path(x).with_suffix('').with_suffix('').name}_BCD_Original2ACPC_transform.h5"
        for x in input_vols
    ]
    task.inputs.outputLandmarksInACPCAlignedSpace = [
        f"{task.inputs.resultsDir}/{Path(x).with_suffix('').with_suffix('').name}_BCD_ACPC_Landmarks.fcsv"
        for x in input_vols
    ]
    
    # Scalar Split the inputs based on input volume and the files generated by BCD
    task.split(
        (
            "inputVolume",
            "outputLandmarksInACPCAlignedSpace",
            "outputLandmarksInInputSpace",
            "outputResampledVolume",
            "outputTransform",
        )
    )
    return task

task = fill_BRAINSConstellationDetector()
t0 = time.time()

print(f"running\n{task.cmdline}")
# Run the task with the concurrent futures plugin
with pydra.Submitter(plugin="cf") as sub:
    sub(task)
print(task.result())
print(f"total time: {time.time() - t0}")
